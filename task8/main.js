//////////////////ЗАдачи

var p = 20;
function test (){
    P = 30;
    var p = 25;
    console.log('result 0', p);
}
function test1 (){
    console.log('result 1', p)
    test2();
}
function test2 (p){
    console.log('result 2', p);
    test3(p);
    function test3 (k){
        var k=30 ;
        console.log('result 3', k)
    }
}
function test4 (M){
    test4();
    console.log('result 4',M)
}
test();
test1(33);
test2(10);
test3(p).
test4(p);
 
сonsole.log('result 5', p); 

/////////////////////////////////

/*вызываем test();
    Функция test() внутри себя перезаписывает переменную р;
    console.log('result 0', p) обращается к переменной р которую тут же находит в окружении функции
    в консоле выведет 
'result 0' = 25



*/
/*вызываем test1(33);
    console.log('result 1', p) обращается к р которую не находит у себя в LexicalEnvironment,
    и ищет в своем Scope , находит в глобальной видимости
'result 1' = 20
    вызывается функция test2(), (она уже была проинициализирована интерпритатором при первом проходе и поднята(?);
    console.log('result 2', p);
'result 2', p=20 ,  значение аргумента берется из глобальной области видимости
ошибся!!!!test2() вызывается без параметров! при инициализации параметру р было присвоенно значение undefined;
'result 2', p=undefined. переменная как свойство объекта есть а значение не присвоено.


        здесь test3(к) в качестве параметра получает р из глобалки но  console.log обращается к перезаписаной внутри
        переменной к
 'result 3', k=30    

*/

/*
test2(10);

    эта функция теперь вместо глобального значения в  LexicalEnvironment присваивает свойство р = 10ж
    поэтому 

    'result 2', p=10
    'result 3', k=30...тоже самое console.log обращается к перезаписаной внутри
        переменной к


*/ 

/*
test3(р);

    Должна быть ошибка, функция test3(), внутри локальной области видимостиб
    к ней обратится можно если переписать с создание замыкания
    например так...

    var p = 20;
    function test2 (){
    
    return function test3 (k){
        
         console.log('result 3', k)  
    }
}
var foo = test2();
foo(p);
'result 3', 20



*/ 

/*
test4(p);
    бесконечная рекурсия
*/

//'result 5' 20;